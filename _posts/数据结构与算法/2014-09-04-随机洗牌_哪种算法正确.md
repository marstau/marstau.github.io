---
layout: post
title: 随机洗牌:哪种算法正确
category: 数据结构与算法
tags: data　structure／algorithm
keywords: 
description: 
---

 

1. for i:=1 to n do swap(a[i], a[random(1,n)]);

2. for i:=1 to n do swap(a[i], a[random(i,n)]);

 

如果不仔细思考的话，绝大多数人会认为第一个算法才是真正随机的，因为它的操作“更对称”，保证了概率均等。但静下心来仔细思考，你会发现第二种算法才是真正满足随机性的。为了证明这一点，只需要注意到算法的本质是“随机确定a[1]的值，然后递归地对后n-1位进行操作”，用数学归纳法即可轻易说明算法的正确性。而事实上，这段程序一共将会产生n\*(n-1)\*(n-2)\*...\*1种等可能的情况，它们正好与1至n的n!种排列一一对应。

有人会问，那第一种算法为什么就错了呢？看它的样子多么对称美观啊……且慢，我还没说第一种算法是错的哦！虽然第一种算法将产生比第二种算法更多的可能性，会导致一些重复的数列，但完全有可能每种数列重复了相同的次数，概率仍然是均等的。事实上，更有可能发生的是，这两种算法都是正确的，不过相比之下呢第一种算法显得更加对称美观一些。为此，我们需要说明，第一种算法产生的所有情况均等地分成了n!个等价的结果。显然，这个算法将会产生n\^n种情况，而我们的排列一共有n!个，因此n\^n必须能够被n!整除才行（否则就不能均等地分布了）。但是，n!里含有所有不超过n的质数，而n\^n里却只有n的那几个质因子。这表明要想n\^n能被n!整除，n的质因子中必须含有所有不超过n的质数。这个结论看上去相当荒唐，反例遍地都是，并且直觉上告诉我们对于所有大于2的n这都是不成立的。为了证明这一点，只需要注意到2是质数，并且根据Bertrand-Chebyshev定理，在n/2和n之间一定还有一个质数。这两个质数的乘积已经大于n了。

算法导论有证明.







